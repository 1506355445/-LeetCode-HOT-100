1072. 按列翻转得到最大值等行数
给定 m x n 矩阵 matrix 。

你可以从中选出任意数量的列并翻转其上的 每个 单元格。（即翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。）

返回 经过一些翻转后，行与行之间所有值都相等的最大行数 。

示例 1：

输入：matrix = [[0,1],[1,1]]
输出：1
解释：不进行翻转，有 1 行所有值都相等。

示例 2：

输入：matrix = [[0,1],[1,0]]
输出：2
解释：翻转第一列的值之后，这两行都由相等的值组成。

示例 3：

输入：matrix = [[0,0,0],[0,0,1],[1,1,0]]
输出：2
解释：翻转前两列的值之后，后两行由相等的值组成。

思路：1.若是需要暴力枚举解题，我们首先思考这个问题，要如何确定翻转哪些列？因为我们翻转的目的，是保证其中一行全是0（或者1）。所以我们可以考虑枚举每一行，使得这一行全部变成0（或者1），
然后统计其他行是否有所有值都相等的。

2.进一步考虑发现，我们没有必要对固定的哪一行真正进行翻转。当某两行的值完全相等或 完全相反时，通过翻转列，我们总能把它们同时变为符合条件的行。

我们可以用每一行中的每个元素相对第一个元素是否相同来组成一个特征字符串，用于代表这一行的特性。也就是说特征字符串相同的行，一定会同时变成满足条件的行（全是0或者1）。反之，若是不相同，
一定不能同时变成满足条件的字符串。
举例说：对行100，它的特征字符串都是011。对行011，它的特征字符串也是011。因此它们一定能同时变成满足题目要求的行。事实上，我们只要翻转第一列就可以了。

3.最后，我们用一个哈希表统计每个特征字符串的频率，频率最高的就是我们要的答案。

//time complexity:O(mn)
//space complexity:O(m)

class Solution {
public:
    int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {
        unordered_map<string,int> mapping;
        for(auto& row:matrix){
            string ele="";
            for(auto& val:row){
                ele += val==row[0]?'0':'1';
            }
            mapping[ele]++;
        }
        int ans=0;
        for(auto&[key,val]:mapping){
            ans=max(ans,val);
        }
        return ans;
    }
};

在平面直角坐标系里，给定n个工人的坐标和m个自行车的坐标（m ≥ n并且它们的坐标两两不同），问怎样分配才能使得每个工人都有一个自行车，并且工人与自行车的曼哈顿距离之总和最小。
返回那个最小的距离总和。

思路：如果用简单的暴力破解，用dfs把所有取法都遍历一遍，时间复杂度O（N!）。这里是不能通过测试的。
因此我们需要用 backtracking + memoization 的方法做优化，用一个数 state 表示已经选取了的bike的组合。这样memo[state]就表示在当前选取的自行车组合下，之后能得到的最小和。
这是一种bottom up的思想。
这里有一个技巧，我们用二进制的思想构造state，因为自行车的数量不超过10个，那么在第i个位置上，如果等于1，则说明第i辆自行车被选择了，否则就是没被选择。

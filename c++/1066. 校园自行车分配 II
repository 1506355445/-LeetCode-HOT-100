在平面直角坐标系里，给定n个工人的坐标和m个自行车的坐标（m ≥ n并且它们的坐标两两不同），问怎样分配才能使得每个工人都有一个自行车，并且工人与自行车的曼哈顿距离之总和最小。
返回那个最小的距离总和。

思路：如果用简单的暴力破解，用dfs把所有取法都遍历一遍，时间复杂度O（N!）。这里是不能通过测试的。
因此我们需要用 backtracking + memoization 的方法做优化，用一个数 state 表示已经选取了的bike的组合。这样memo[state]就表示在当前选取的自行车组合下，之后能得到的最小和。
这是一种bottom up的思想。
这里有一个技巧，我们用二进制的思想构造state，因为自行车的数量不超过10个，那么在第i个位置上，如果等于1，则说明第i辆自行车被选择了，否则就是没被选择。

class Solution{
  int assignBikes(vector<vector<int>>& workers,vector<vector<int>>& bikes){
    vector<vector<int>> dp(workers.size(),vector<int>(bikes.size(),0));
    for (auto i=0;i<workers.size();++i){
        for(auto j=0;i<bikes.size();++j){
            dp[i][j]=dist(workers[i],bikes[j]);
        }
    }
    int res=INT_MAX;
    vector<int> memo(1<<bikes.size(),0);//1左移n位(bikes.size())，相当于2^n
    return dfs(dp,memo,0,0);
  }
private:
    int dist(const vector<int>& worker,const vector<int>& bike){
        return abs(worker[0]-bike[0])+abs(worker[1]-bike[1]);
    }
    //idx表示目前选择的是第几个worker
    int dfs(const vector<vector<int>>& dp,vector<int>& memo,int state,int idx){
        if(idx == dp.size()){
            return 0;
        }
        if(memo[state]!=0){
            return memo[state];
        }
        int tmp=INT_MAX;
        for(auto j=0;j<dp[0].size();j++){
            if((state&(1<<j)) ==0){
                tmp=min(tmp,dp[idx][j]+dfs(dp,memo,state | (1<<j),idx+1);
            }
        }
        memo[state]=tmp;
        return memo[state];
    }
};
